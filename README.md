# Установка

1. Скачать проект из репозитория
2. Выполнить npm install
3. Выполнить npm run start
4. Игра запустится на localhost:8080

# Мотивация

В данный момент я занимаюсь разработкой собственной ECS-библиотеки для игр на Typescript, которую можно интегрировать с Pixi, ThreeJS, CocosCreator и другими графическими библиотеками или игровыми движками. Это тестовое задание стало отличным поводом протестировать библиотеку в действии. Получившийся проект может казаться внешне немного топорным. Это обусловлено тем, что для меня это тестовое стало больше как R&D по выявлению слабых сторон разрабатываемого инструмента. Однако, “под капотом” реализовано много интересных, спорных и даже неудачных решений на которые стоит взглянуть.

У меня нет пока планов использовать библиотеку где-то в продакшене, это скорее как эксперимент и просто забавная практика. Впрочем, если полученный результат в итоге меня удовлетворит, то почему бы и нет?

Ниже я попытался вкратце описать на чем основывается проект для упрощения проведения ревью тестового задания.

[Исходный код Mysh](https://github.com/YettiKetchup/mysh)

[Интеграция с Pixi](https://github.com/YettiKetchup/mysh-pixi)
(пока очень сыро и грязно, но в целом свою работу выполняет)

# ECS и Mysh

## Коротко про Entity Component System

Итак, Entity Component System - это архитектурный шаблон проектирования, который позволяет разделять логику и данные, что привносит элементы декларативности и позволяет писать очень гибкий и устойчивый к изменениям код. А изменения в игровых проектах это история довольно частая и ECS отличное решение, чтобы эксперименты гейм-дизайнера с механиками не привели к обрушению всего игрового приложения.

Гибкость достигается за счет разделения всего и вся. Данные лежат отдельно от логики и не меняются под требования логики, логика ничего не знает про конкретные игровые объекты и работает исходя из набора данных. Игровые объекты же просто содержат в себе состояния и не обладают никаким поведением.

Чтобы было понятней, стоит рассмотреть на примерах. Допустим у нас есть класс игрока Player со свойством health, отвечающем за жизнь игрока, и методом, который жизнь восстанавливает. В “стандартном” ООП-подходе, назовем это так, мы бы реализовали что-то подобное:

```

  class Player {
    public health: number = 100;


    public heal(value: number): void {
      this.health += value;
    }
  }

```

Либо же можем вынести логику лечения в другой класс, который, собственно, по всем правилам декомпозиции должен как раз за это отвечать.

```

  class Player implements IHealable {
    public health: number = 100;
  }


  class HealingLogic {
    public heal(gameObject: IHealable, value: number): void {
      gameObject.health += value;
    }
  }

```

Но проблема в том, что у нас в игре объектов отвечающих за лечение может быть множество: пикапы, триггеры, условия окончания квестов, покупки бонусов, айтемы инвентаря, читы и прочее-прочее. Также нам возможно нужно “лечить” большое количество разных объектов: игроков, неписей, какие-то объекты окружения также могут обладать здоровьем, отвечающим за степень их повреждения и они также могут быть “исцелены”. И какие-то объекты после “лечения” могут инициировать события, какие-то нет. Что если после “лечения” вот того ящика нужно запустить квест или поменять его стадию? А что если изменить внешний вид, а у других внешний вид не меняется? И чем больше типов “лечилок” и “лечимых” объектов, тем больше у нас разница в поведении между этими объектами, тем больше абстракций, тем больше риска все сломать, когда нам где-то что-то нужно поменять. Да, есть GoF-паттерны, которые в 90% решают эти проблемы, но это еще нужно их всех помнить и понимать когда нам нужен паттерн State, а когда проще и лучше использовать Behaviour.

Entity Component System это один паттерн, который применяется ко всему приложению и решает все эти проблемы связанные с наделением объектов новым функционалом, его изменением. По-крайней мере большую их часть. Есть множество различных реализаций от строгих, где все, даже рендеринг объектов осуществляется через ECS, до гибридных, где ECS выносится на отдельный слой и работает только с игровыми объектами и их взаимоотношениями, а остальное вокруг них, реализовывается как угодно.

Все, с чем мы работаем используя такой подход, уже указано в названии паттерна, само ядро, а остальное это уже особенности реализации.

У нас есть Components, которые являются единицами данных отвечающих за состояние игрового объекта. В Компонентах мы храним только данные и никакой логики за очень редкими исключениями.

У нас есть Entities, которые являются игровыми объектами, которые приобретают определенные свойства храня в себе наборы Компонентов. Сущности также не могут хранить в себе никакой игровой логики, кроме той, которая управляет Компонентами внутри самой Сущности.

И у нас есть Systems, которые отвечают за логику работы Сущностей исходя из их набора компонентов. Никаких данных, относящихся к игровым объектам, Системы хранить в себе не могут.

Если бы мы попытались создать логику лечения из прошлого примера, то в Mysh это выглядело бы примерно так:

```

  class HealthComponent {
    public value: number = 100;
  }


  class HealingComponent {
    constructor(public value: number) {}
  }


  const player = new Entity();
  player.add(new HealthComponent());


  // Где-то в рантайме добавим еще один Компонент
  player.add(new HealingComponent(10));


  @Includes(HealthComponent, HealingComponent)
  class HealingSystem extends System {
    protected onExecute(entities: Filtered<Entity>): void {
      entities.loop((entity) => {
        const health = entity.get(HealthComponent);
        const healing = entity.get(HealingComponent);


        health.value += healing.value;


        entity.remove(HealingComponent);
      });
    }
  }

```

Что мы имеем. У нас есть Сущность player, которая содержит в себе компонент HealthComponent. Есть компонент HealingComponent, который также добавляется к Сущности игрока, но уже где-то в рантайме, мы не знаем когда. И есть Система HealingSystem, которая, допустим, выполняется каждый фрейм в игровом цикле. И как раз в этой системе мы и лечим нашего игрока. Но идея в том, что только мы знаем, что это игрок. Система этого не знает. Она работает со всеми Сущностями у которых есть Компоненты HealthComponent и HealingComponent. Как только к какой-то Сущности, у которой уже есть HealthComponent, добавится HealingComponent, Система тут же отработает и “подлечит” Сущность. А что это за Сущность - уже неважно. И для того, чтобы добавить новые типы объектов с логикой “излечения” нам нужно просто добавить к ним два компонента. Именно Компонента. Система существует в единичном экземпляре, она создается всего один раз. Да, она может быть вызвана в разных цепочках при разных условиях, но идея в том, что логика у нас одна для всех “исцеляемых” объектов. И эту логику не нужно создавать для каждого объекта отдельно, не нужно пробрасывать ее как зависимость, не нужно от нее наследоваться.

## Реализация Mysh

Mysh это гибридная реализация, которая отвечает только за поведение игровых объектов. Рендер и все, что с ним связано, как в случае с этим проектом, лежит на Pixi и все вьюхи игровых объектов создаются через класс ViewBuilder реализовывающий паттерн Builder. Что, кстати, оказалось на практике немного спорным решением в виду его незавершенности. Так как есть случаи, когда мне нужно было создавать вьюху через простенькую фабрику и уже результат передавать в билдер, потому что сам билдер уже разросся до безобразия и расширять еще сильнее как-то не очень хочется. Это можно увидеть в примере с текстами в данном проекте. В будущем, я планирую еще поиграться с тем, чтобы хотя бы на уровне best practices разделять вьюхи на фабрики, если это небольшие единицы, и билдеры, если это что-то сильно вложенное и комплексное.

Вообще Mysh сам по себе не работает ни с Pixi, ни с ThreeJS, за это отвечают интеграционные слои, которые вынесены в отдельные библиотеки. В случае с этим проектом, это mysh-pixi. Эти библиотеки выступают в роли обертки, которые интегрируют Mysh вместе с тем же Pixi. Создать универсальное решение для всего не представляется возможным из-за сильной разницы апих графических библиотек, но написать слой интеграции довольно просто.

Помимо стандартного набора ECS из примера выше в Mysh есть Chain, который позволяет создать цепочки последовательного вызова Систем, даже, если какие-то асинхронны. А Системы могут быть асинхронными. Таймеры и анимации еще никто не отменял, а нам нужно использовать такие Системы так, что бы другие Системы следующие далее по цепочке дожидались окончания выполнения работы текущей. И больше того, в Цепочках можно расширять фильтр Системы, чтобы ограничить типы Сущностей с которой работает эта Система, но при этом не нарушать принцип Open-Closed внося изменения в саму Систему, либо не нарушать принцип DRY копируя код Системы просто потому, что нам пришлось расширить фильтр. Именно расширить, а не заменить. Если набор Компонентов в фильтре сильно меняется, то уже проще переписать.

Также, есть EntityStorage и EntitiesCollection, которые хранят в себе все Сущности. EntityStorage просто помогает управлять всеми нашими EntitiesCollection. Очень полезно для производительности хранить Сущности из разных доменных областей в разных коллекциях. Например, когда Система работает с Сущностями относящимся к конкретно игровым объектам, не очень хочется, чтобы она при фильтрации проходила все объекты из интерфейса. И наоборот.

Есть реализации реактивного слежения за изменениями Сущностей и Компонентов через EntitySubject и EntityObservable. Например, мы можем подписаться на изменения компонента HealthComponent и запускать по этому событию Цепочки Систем. Самое классное, что через пайпинги мы можем гибко настраивать за какими конкретными Сущностями следить. Мы следим за изменениями значения в HealthComponent, но с помощью пайпов мы можем сузить область слежения до “только у тех Сущностей у которых еще есть компонент PlayerComponent и нет Компонента CheatGodComponent”. И таким образом будут игнорироваться все изменения HealthComponent у Сущностей с другим набором Компонентов.

И еще есть Modules и Stages, которые схожи между собой по интерфейсу, но различаются по своей сути. Modules инициализируют прослушку событий, запускают Системы и Цепочки и вообще являются логической единицей помогающей как-то разбить игровое приложение на части. Сцены же загружают ассеты и инициализируют Модули. Модуль, кстати, не обязательно должен иметь свой класс, это может быть просто папка со всем, что относится к определенному типу игровых объектов. Например, модуль environment-module не имеет своего класса Модуля, там просто лежат вьюхи и данные для объектов декораций и все.

Скорее всего, в будущем, я как-то автоматизирую работу с Модулями, так как в 99% случаев Модуль просто инициализирует Чейн, в нем вешаются прослушки на события Компонентов и перебрасывается экземпляр EntitiesColelction в те же Цепочки. Все Моудли в тестовом задании делают именно это и ничего более за исключением ResizeModule, который вешает прослушку на ресайз ноды канвасы. Поэтому возникла идея подумать над тем, чтобы автоматизировать этот рутинный процесс.

## Структура и организация кода

Мне очень нравится подход FSD в React, поэтому я постарался реализовать что-то подобное. Опять же, больше в качестве эксперимента, но результатом я, в целом, доволен и задумаюсь над тем, чтобы использовать это в продакшене.

Если вкратце, то FSD - архитектурно-структурное решение-методология, которое помогает организовывать файлы в проекте таким образом, чтобы с ним было удобно работать. Основная идея это разбиение по слоям, чтобы избегать вертикальных зависимостей и зависимостей от слоев верхнего уровня нижними.Мы просто разбиваем наше приложение на слои по уровням абстракции: от самых абстрактных типа всяких тулзов до максимально конкретизированных типа реализация игрового объекта танка и всей его логики. И нижние слои не могут обращаться к верхним. Более того, сущности на одном слое не могут взаимодействовать между собой. Например, если какой-то модуль использует другой модуль, то это тмодуль следует перенести на слой выше в widgets. А если два виджета взаимодействовать между собой, то что-то тут не уже так.

В моей реализации есть 8 слоев, все по порядку от верхнего до нижнего: app, stages, widgets, modules, systems, views, components, shared.

В **app** мы храним все, что касается всего приложения: инициализация рендера, тикера, менеджера сцен и так далее.

В **stages** у нас, понятное дело, хранятся сцены, которые используют все, что лежит в уровнях ниже.

В **widgets** у нас хранятся высокоуровневые модули, которые используют в качестве зависимостей модули нижнего уровня и расширяют их функционал. Например, в тестовом задании танк это виджет так как он использует части модулей отвечающих за стрельбу и логику работы снарядов. Если проще, то Виджеты это модули максимально конкретизированные, с минимальным уровнем абстракции. Мне кажется, что оригинальное название widgets этому слою в данной реализации не очень подходит, но я пока не придумал ему название получше.

В **modules** у нас лежат простенькие одинокие модули, которые выполняют какую-то одну задачу и не имеют зависимостей от других модулей со средним уровнем абстракции. Например, есть projectile модуль, который отвечает за полет снаряда и его внешний вид. Он не использует другие модули, но используется в виджете танка и может быть использован в других виджетах, например, как у нас появятся турели, самолеты, да что угодно, что может стрелять.

В **systems** лежат Системы, которые могут использоваться Модулями и Виджетами. Такие Системы довольно абстрактные и зачастую выполняют какие-то системные функции, например как Система DestroyEntitySystem. Вообще эта Система должна быть частью библиотеки Mysh, но я пока не работал над встроенными Системами и Компонентами, поэтому на данный момент слой systems для нее самое место.

Во **views** лежат всякие универсальные вьюхи, шаблоны, которые могут использоваться Модулями, Виджетами, Системами для создании на игровой сцене и даже самими Сценами. В тестовом задании там лежит шаблон для создания декораций (кусты, баррикады) и bar для хелсбара и повербара, которые определены в модулях выше.

В **components** лежат Компоненты, которые могут быть использованы во всех слоях выше при необходимости. В тестовом задании не представлен.

Ну и **shared** как понятно из названия это что-то общее для всего проекта. Конфиги, апихи, какие-то универсальные переносимые из проекта в проект модули, тулзы с утилитами.

## Немного выводов об использовании Mysh

В целом, реализация уже близка к той, что я себе представлял изначально. С Mysh действительно можно писать в декларативном стиле, приложение будет устойчивым к изменениям, все части будут независимы и можно много чего прикольного создать, что было бы довольно сложным в реализации без ECS. Например, модуль ресайзинга, который я быстро написал исключительно ради тестов и он пока еще сыроват, но уже свою работу кое-как да делает в рамках этого задания. Я могу с помощью Компонентов определять поведение каждого отдельного объекта при ресайзе. Причем у каждого будет свое. Кто-то скейлится, кто-то меняет позицию, у кого-то меняются якоря и пивоты, у кого-то все сразу, кто-то будет стараться замостить весь экран собой и так далее.

Но также есть и неудобства. Во-первых, огромное количество файлов. Гигантское. Понятно, что следуя Single Responsibility приходится дробить все так, чтобы каждый класс или функция отвечали за что-то одно. Но тут еще добавляются Компоненты, Чейны, Модули… Структурирование по FSD сильно помогает это все организовывать и контролировать, но бывает теряешься и забываешь какие Компоненты уже есть, какие Системы сделаны и от чего они зависят, где какая вьюха лежит. Впрочем, FSD тоже немного портит удобство использования поскольку файлы размазываются по слоям.

Во-вторых, из-за того, что работа с Модулями и Чейнами это рутина, больше концентрируешься не на логике, а на контроле того как это все должно запускаться и в какие моменты отрабатывать. Выглядит это примерно так: “Мы зажали кнопку стрельбы, она реактивно на старте добавила себе Компонент HoldedButon значит в этот момент мы должны создать прицел, снаряд, передать данные из кнопки о типе боеприпаса и пока мы держим кнопку срабатывает событие изменения и в этот момент мы должны запустить индикатор и дублировать данные в снаряд, который нужно сделать невидимым, потому что он мне нужен уже на сцене…”. Nuff said.

Ну и сырость интеграционного с Pixi слоя тоже удобства работе не добавляет. Обработка событий на клики кнопки это жесть.

В любом случае, я добился чего хотел. И тестовое сделал и слабые места библиотеки выявил на более-менее реальном проекте с вполне адекватными требованиями к логике.

# Теперь о самом проекте

## Что реализовано

Да в целом, все, что указано в ТЗ, и немного больше.

- ✅ Изометрическая top-down локация
- ✅ Два недвигающихся персонажа за статическими ограждениями
- ✅ Игра за одного персонажа
- ✅ Броски гранат с разными характеристиками
- ✅ Партиклы взрывов
- ✅ Механика попадания и промаха с перелетами и недолетами
- ✅ Для броска гранаты удерживать кнопку с индикацией силы броска
- ✅ Блокировка кнопок до тех пор, пока граната не взорвется
- ✅ Появление цели после того как игрок отпустил кнопку броска
- ✅ Полет гранаты по кривой траектории (Высота подлета зависит от дистанции, чем дальше, тем ниже летит)
- ✅ Нанесение урона противнику с обновлением хелсбара
- ✅ Завершение игры, если у противника осталось 0 хп
- ⚠️ Игровой цикл, рестарт
- ✅ Ресайзы под мобильные девайсы с разными ориентациями
- ✅ Хорошая организация файлов в проекте
- ✅ Чистый код (кроме того места, где снаряд анимируется через gsap)
- ❌ Комментарии
- ✅ Инициатива в работе с архитектурой :)

## Known Issues

- Игра рестартует через location.reload() вместо того, чтобы перезагрузить сцену через StageManager, поскольку тот пока не доделан.

- Также игра не заканчивается поражением, когда заканчиваются все боеприпасы.

- //prettier-ignore в файлах с билдерами. Почему-то мой плагин prettier для VSCode игнорирует правила для чейнингов.
